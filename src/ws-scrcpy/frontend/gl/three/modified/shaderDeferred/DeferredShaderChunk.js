const DeferredShaderChunk = {
	unpackFloat: 'vec3 float_to_vec3( float data ) {\n'
    + 'vec3 uncompressed;\n'
    + 'uncompressed.x = fract( data );\n'
    + 'float zInt = floor( data / 255.0 );\n'
    + 'uncompressed.z = fract( zInt / 255.0 );\n'
    + 'uncompressed.y = fract( floor( data - ( zInt * 255.0 ) ) / 255.0 );\n'
    + 'return uncompressed;\n'
    + '}',
	computeVertexPositionVS: 'vec2 texCoord = gl_FragCoord.xy / vec2( viewWidth, viewHeight );\n'
    + 'vec4 normalDepth = texture2D( samplerNormalDepth, texCoord );\n'
    + 'float z = normalDepth.w;\n'
    + 'if ( z == 0.0 ) discard;\n'
    + 'vec2 xy = texCoord * 2.0 - 1.0;\n'
    + 'vec4 vertexPositionProjected = vec4( xy, z, 1.0 );\n'
    + 'vec4 vertexPositionVS = matProjInverse * vertexPositionProjected;\n'
    + 'vertexPositionVS.xyz /= vertexPositionVS.w;\n'
    + 'vertexPositionVS.w = 1.0;',
	computeNormal: 'vec3 normal = normalDepth.xyz * 2.0 - 1.0;',
	unpackColorMap: 'vec4 colorMap = texture2D( samplerColor, texCoord );\n'
    + 'vec3 albedo = float_to_vec3( abs( colorMap.x ) );\n'
    + 'vec3 specularColor = float_to_vec3( abs( colorMap.y ) );\n'
    + 'float shininess = abs( colorMap.z );\n'
    + 'float wrapAround = sign( colorMap.z );\n'
    + 'float additiveSpecular = sign( colorMap.y );',
	computeDiffuse: 'float dotProduct = dot( normal, lightVector );\n'
    + 'float diffuseFull = max( dotProduct, 0.0 );\n'
    + 'vec3 diffuse;\n'
    + 'if ( wrapAround < 0.0 ) {\n'
    + 'float diffuseHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n'
    + 'const vec3 wrapRGB = vec3( 1.0, 1.0, 1.0 );\n'
    + 'diffuse = mix( vec3( diffuseFull ), vec3( diffuseHalf ), wrapRGB );\n'
    + '} else {\n'
    + 'diffuse = vec3( diffuseFull );\n'
    + '}',
	computeSpecular: 'vec3 halfVector = normalize( lightVector - normalize( vertexPositionVS.xyz ) );\n'
    + 'float dotNormalHalf = max( dot( normal, halfVector ), 0.0 );\n'
    + 'float specularNormalization = ( shininess + 2.0001 ) / 8.0;\n'
    + 'vec3 schlick = specularColor + vec3( 1.0 - specularColor ) * pow( 1.0 - dot( lightVector, halfVector ), 5.0 );\n'
    + 'vec3 specular = schlick * max( pow( dotNormalHalf, shininess ), 0.0 ) * diffuse * specularNormalization;',
	combine: 'vec3 light = lightIntensity * lightColor;\n'
    + 'gl_FragColor = vec4( light * ( albedo * diffuse + specular ), attenuation );',
	shadowMapPCF: 'float sampleShadowPCF( sampler2D shadowMap, vec2 shadowMapSize, vec2 shadowCoord, float vertexDepth ) {\n'
    + 'float shadowDepth;\n'
    + 'float shadowValue = 0.0;\n'
    + 'const float shadowDelta = 1.0 / 9.0;\n'
    + 'float xPixelOffset = 1.0 / shadowMapSize.x;\n'
    + 'float yPixelOffset = 1.0 / shadowMapSize.y;\n'
    + 'float dx0 = -1.25 * xPixelOffset;\n'
    + 'float dy0 = -1.25 * yPixelOffset;\n'
    + 'float dx1 = 1.25 * xPixelOffset;\n'
    + 'float dy1 = 1.25 * yPixelOffset;\n'
    + 'shadowDepth = texture2D( shadowMap, shadowCoord + vec2( dx0, dy0 ) ).x;\n'
    + 'shadowValue += shadowDelta * float( vertexDepth > shadowDepth );\n'
    + 'shadowDepth = texture2D( shadowMap, shadowCoord + vec2( 0.0, dy0 ) ).x;\n'
    + 'shadowValue += shadowDelta * float( vertexDepth > shadowDepth );\n'
    + 'shadowDepth = texture2D( shadowMap, shadowCoord + vec2( dx1, dy0 ) ).x;\n'
    + 'shadowValue += shadowDelta * float( vertexDepth > shadowDepth );\n'
    + 'shadowDepth = texture2D( shadowMap, shadowCoord + vec2( dx0, 0.0 ) ).x;\n'
    + 'shadowValue += shadowDelta * float( vertexDepth > shadowDepth );\n'
    + 'shadowDepth = texture2D( shadowMap, shadowCoord ).x;\n'
    + 'shadowValue += shadowDelta * float( vertexDepth > shadowDepth );\n'
    + 'shadowDepth = texture2D( shadowMap, shadowCoord + vec2( dx1, 0.0 ) ).x;\n'
    + 'shadowValue += shadowDelta * float( vertexDepth > shadowDepth );\n'
    + 'shadowDepth = texture2D( shadowMap, shadowCoord + vec2( dx0, dy1 ) ).x;\n'
    + 'shadowValue += shadowDelta * float( vertexDepth > shadowDepth );\n'
    + 'shadowDepth = texture2D( shadowMap, shadowCoord + vec2( 0.0, dy1 ) ).x;\n'
    + 'shadowValue += shadowDelta * float( vertexDepth > shadowDepth );\n'
    + 'shadowDepth = texture2D( shadowMap, shadowCoord + vec2( dx1, dy1 ) ).x;\n'
    + 'shadowValue += shadowDelta * float( vertexDepth > shadowDepth );\n'
    + 'return shadowValue;\n'
    + '}',
	shadowMapPCFSoft: 'float sampleShadowPCFSoft( sampler2D shadowMap, vec2 shadowMapSize, vec2 shadowCoord, float vertexDepth ) {\n'
    + 'float shadowDepth;\n'
    + 'float shadow = 0.0;\n'
    + 'float xPixelOffset = 1.0 / shadowMapSize.x;\n'
    + 'float yPixelOffset = 1.0 / shadowMapSize.y;\n'
    + 'float dx0 = -1.0 * xPixelOffset;\n'
    + 'float dy0 = -1.0 * yPixelOffset;\n'
    + 'float dx1 = 1.0 * xPixelOffset;\n'
    + 'float dy1 = 1.0 * yPixelOffset;\n'
    + 'mat3 shadowKernel;\n'
    + 'shadowDepth = texture2D( shadowMap, shadowCoord + vec2( dx0, dy0 ) ).x;\n'
    + 'shadowKernel[0][0] = 0.25 * float( vertexDepth > shadowDepth );\n'
    + 'shadowDepth = texture2D( shadowMap, shadowCoord + vec2( dx0, 0.0 ) ).x;\n'
    + 'shadowKernel[0][1] = 0.25 * float( vertexDepth > shadowDepth );\n'
    + 'shadowDepth = texture2D( shadowMap, shadowCoord + vec2( dx0, dy1 ) ).x;\n'
    + 'shadowKernel[0][2] = 0.25 * float( vertexDepth > shadowDepth );\n'
    + 'shadowDepth = texture2D( shadowMap, shadowCoord + vec2( 0.0, dy0 ) ).x;\n'
    + 'shadowKernel[1][0] = 0.25 * float( vertexDepth > shadowDepth );\n'
    + 'shadowDepth = texture2D( shadowMap, shadowCoord ).x;\n'
    + 'shadowKernel[1][1] = 0.25 * float( vertexDepth > shadowDepth );\n'
    + 'shadowDepth = texture2D( shadowMap, shadowCoord + vec2( 0.0, dy1 ) ).x;\n'
    + 'shadowKernel[1][2] = 0.25 * float( vertexDepth > shadowDepth );\n'
    + 'shadowDepth = texture2D( shadowMap, shadowCoord + vec2( dx1, dy0 ) ).x;\n'
    + 'shadowKernel[2][0] = 0.25 * float( vertexDepth > shadowDepth );\n'
    + 'shadowDepth = texture2D( shadowMap, shadowCoord + vec2( dx1, 0.0 ) ).x;\n'
    + 'shadowKernel[2][1] = 0.25 * float( vertexDepth > shadowDepth );\n'
    + 'shadowDepth = texture2D( shadowMap, shadowCoord + vec2( dx1, dy1 ) ).x;\n'
    + 'shadowKernel[2][2] = 0.25 * float( vertexDepth > shadowDepth );\n'
    + 'vec2 fractionalCoord = 1.0 - fract( shadowCoord * shadowMapSize );\n'
    + 'shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n'
    + 'shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n'
    + 'vec4 shadowValues;\n'
    + 'shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n'
    + 'shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n'
    + 'shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n'
    + 'shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n'
    + 'float shadowValue = dot( shadowValues, vec4( 1.0 ) );\n'
    + 'return shadowValue;\n'
    + '}'
};

export { DeferredShaderChunk };
